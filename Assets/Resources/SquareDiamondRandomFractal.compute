
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Clear
#pragma kernel RandomTest
#pragma kernel StartCorners
#pragma kernel Diamond
#pragma kernel Square
#pragma kernel SquareLeftSide
#pragma kernel SquareTopSide
#pragma kernel SquareRightSide
#pragma kernel SquareBottomSide

// Visit https://en.wikipedia.org/wiki/Diamond-square_algorithm if you need a visual aid on what this shader is doing!

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float> read;
RWTexture2D<float> write;
uniform uint randomSeed;
uniform uint widthMinusOne;
uniform uint iteration;
uniform float variation;
uniform bool keepEdges;
uniform float fitExistingTerrain;

inline float rand_float(uint input)
{
	return frac(sin(dot(float2(input / 65536.0, input / 65536.0), float2(12.9898, 78.233)))*43758.5453123);
}

inline float average4(float a, float b, float c, float d)
{
	//return (a + b + c + d) / 4.0;
	return (max(max(a, b), max(c, d)) + min(min(a, b), min(c, d))) / 2.0;
}
inline float average3(float a, float b, float c)
{
	//return (a + b + c) / 3.0;
	return (max(max(a, b), c) + min(min(a, b), c)) / 2.0;
}

inline uint pixel_to_seed(uint x, uint y)
{
	return randomSeed + x + widthMinusOne * y;
}

inline float rand_offset_with_variation(uint x, uint y)
{
		return (rand_float(pixel_to_seed(x, y)) - 0.5) * variation;
}

inline float rand_offset_with_variation_and_tendency(uint x, uint y, float diff)
{
	float rand = rand_float(pixel_to_seed(x, y)) - 0.5;
	rand *= variation;
	float diffClamped = clamp(diff, -0.5f * variation, 0.5f * variation); // cap maximum diff to 0.5
	float currentFit = (1 - pow(fitExistingTerrain, iteration));
	//float currentFit = 0;
	//rand = diff > 0 ? max(diffClamped - currentFit, rand) : min(diffClamped + currentFit, rand);
	rand = clamp(rand, diffClamped - currentFit, diffClamped + currentFit);
	//rand = diffClamped;
	return rand;
}

inline float sample_read(uint x, uint y)
{
	return read[uint2(x, y)];
}

[numthreads(8, 8, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
	write[id.xy] = 0.5;
}

[numthreads(8, 8, 1)]
void RandomTest(uint3 id : SV_DispatchThreadID)
{
	write[id.xy] = rand_float(pixel_to_seed(id.x, id.y));
}

[numthreads(1,1,1)]
void StartCorners (uint3 id : SV_DispatchThreadID)
{
	if (!keepEdges)
	{
		write[uint2(0, 0)] = rand_float(pixel_to_seed(0, 0));
		write[uint2(0, widthMinusOne)] = rand_float(pixel_to_seed(0, widthMinusOne));
		write[uint2(widthMinusOne, 0)] = rand_float(pixel_to_seed(widthMinusOne, 0));
		write[uint2(widthMinusOne, widthMinusOne)] = rand_float(pixel_to_seed(widthMinusOne, widthMinusOne));
	}
}

[numthreads(8, 8, 1)]
void Diamond(uint3 id : SV_DispatchThreadID)
{
	int units = widthMinusOne / (1 << iteration);
	uint2 newXY = uint2(id.x * units * 2 + units, id.y * units * 2 + units);
	float average = average4(sample_read(newXY.x - units, newXY.y - units), \
							sample_read(newXY.x + units, newXY.y - units), \
							sample_read(newXY.x - units, newXY.y + units), \
							sample_read(newXY.x + units, newXY.y + units));

	float target = average + rand_offset_with_variation_and_tendency(newXY.x, newXY.y, read[newXY] - average);
	write[newXY] = target;
}


[numthreads(4, 8, 1)]
void Square(uint3 id : SV_DispatchThreadID) 
{
	// To achieve a "diamond pattern" we multiply the x value by 2 and then add 1 to the x value for every other row
	int units = widthMinusOne / (1 << iteration);
	int rowShift = (id.y + 1) % 2;
	uint2 newXY = uint2(id.x * units * 2 + units * rowShift, id.y * units);
	float average = average4(sample_read(newXY.x - units, newXY.y), \
							sample_read(newXY.x + units, newXY.y), \
							sample_read(newXY.x, newXY.y - units), \
							sample_read(newXY.x, newXY.y + units));

	float target = average + rand_offset_with_variation_and_tendency(newXY.x, newXY.y, read[newXY] - average);
	write[newXY] = target;
}


[numthreads(1, 8, 1)]
void SquareLeftSide(uint3 id : SV_DispatchThreadID)
{
	int units = widthMinusOne / (1 << iteration);
	uint2 newXY = uint2(0, id.y * units * 2 + units);
	if (keepEdges)
	{
		write[newXY] = read[newXY];
	}
	else
	{
		float average = average3(sample_read(newXY.x + units, newXY.y), \
			sample_read(newXY.x, newXY.y - units), \
			sample_read(newXY.x, newXY.y + units));
		write[newXY] = average + rand_offset_with_variation(newXY.x, newXY.y);
	}
}


[numthreads(8, 1, 1)]
void SquareTopSide(uint3 id : SV_DispatchThreadID)
{
	int units = widthMinusOne / (1 << iteration);
	uint2 newXY = uint2(id.x * units * 2 + units, 0);
	if (keepEdges)
	{
		write[newXY] = read[newXY];
	}
	else
	{
		float average = average3(sample_read(newXY.x - units, newXY.y), \
			sample_read(newXY.x + units, newXY.y), \
			sample_read(newXY.x, newXY.y + units));
		write[newXY] = average + rand_offset_with_variation(newXY.x, newXY.y);
	}
}


[numthreads(1, 8, 1)]
void SquareRightSide(uint3 id : SV_DispatchThreadID)
{
	int units = widthMinusOne / (1 << iteration);
	uint2 newXY = uint2(widthMinusOne, id.y * units * 2 + units);
	if (keepEdges)
	{
		write[newXY] = read[newXY];
	}
	else
	{
		float average = average3(sample_read(newXY.x - units, newXY.y), \
			sample_read(newXY.x, newXY.y - units), \
			sample_read(newXY.x, newXY.y + units));
		write[newXY] = average + rand_offset_with_variation(newXY.x, newXY.y);
	}
}

[numthreads(8, 1, 1)]
void SquareBottomSide(uint3 id : SV_DispatchThreadID)
{
	int units = widthMinusOne / (1 << iteration);
	uint2 newXY = uint2(id.x * units * 2 + units, widthMinusOne);
	if (keepEdges)
	{
		write[newXY] = read[newXY];
	}
	else
	{
		float average = average3(sample_read(newXY.x - units, newXY.y), \
			sample_read(newXY.x + units, newXY.y), \
			sample_read(newXY.x, newXY.y - units));
		write[newXY] = average + rand_offset_with_variation(newXY.x, newXY.y);
	}
}